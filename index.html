<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JUJUTSU KAISEN: DOMAIN CLASH - ULTIMATE</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Rajdhani', sans-serif; background: #050505; color: #fff; overflow: hidden; user-select: none; }
        
        #bgCanvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; transition: background 0.5s; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        
        /* Loading Screen */
        #loadingScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #050505; display: flex; align-items: center; justify-content: center; z-index: 1000; }
        #loadingScreen h2 { font-size: 2em; color: #ff0844; animation: pulse 1s infinite; }
        
        /* Title & Screens */
        .title { font-family: 'Orbitron'; font-size: 4em; font-weight: 900; letter-spacing: 6px; margin-bottom: 10px; background: linear-gradient(135deg, #ff0844, #ffb199, #ff0844); -webkit-background-clip: text; -webkit-text-fill-color: transparent; animation: titleGlow 2s ease-in-out infinite; text-align: center; }
        @keyframes titleGlow { 0%, 100% { filter: drop-shadow(0 0 20px rgba(255, 8, 68, 0.5)); } 50% { filter: drop-shadow(0 0 40px rgba(255, 8, 68, 0.8)); } }
        
        #modeScreen { min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #selectionScreen, #mapScreen { display: none; min-height: 100vh; flex-direction: column; align-items: center; justify-content: center; }
        
        .modes-grid, .characters-grid, .maps-grid { display: grid; gap: 15px; padding: 20px; }
        .modes-grid { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); max-width: 1000px; }
        .characters-grid { grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); max-width: 1200px; max-height: 60vh; overflow-y: auto; background: rgba(20, 0, 10, 0.8); border: 2px solid rgba(255, 8, 68, 0.3); border-radius: 20px; }
        .maps-grid { grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); max-width: 1000px; }
        
        .mode-card, .character-card, .map-card { background: linear-gradient(135deg, rgba(30, 10, 20, 0.95), rgba(50, 10, 30, 0.95)); border: 2px solid rgba(255, 8, 68, 0.3); border-radius: 12px; padding: 20px; cursor: pointer; transition: 0.2s; text-align: center; }
        .mode-card:hover, .character-card:hover, .map-card:hover { transform: translateY(-5px); border-color: #ff0844; box-shadow: 0 5px 20px rgba(255, 8, 68, 0.6); }
        .character-card.selected, .map-card.selected { border: 3px solid #00ff88; box-shadow: 0 0 20px rgba(0, 255, 136, 0.5); }
        
        .mode-icon, .character-portrait, .map-preview { font-size: 3em; margin-bottom: 10px; }
        .mode-name, .character-name, .map-name { font-weight: 900; font-size: 1.2em; color: #ff0844; }
        
        /* Game Screen */
        #gameScreen { display: none; width: 100%; height: 100vh; }
        #gameCanvas { display: block; width: 1200px; height: 600px; background: rgba(0,0,0,0.5); border: 4px solid #333; margin: 0 auto; border-radius: 10px; }
        
        /* HUD */
        .hud { width: 1200px; margin: 10px auto; }
        .top-hud { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .round-info, .coins-display { font-size: 1.5em; font-weight: 900; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.5); }
        
        .health-bars { display: flex; justify-content: space-between; gap: 40px; margin-bottom: 10px; }
        .health-group { flex: 1; }
        .health-label { font-size: 1.2em; font-weight: 900; margin-bottom: 5px; display: flex; justify-content: space-between; text-shadow: 2px 2px 0 #000; }
        .health-bar-outer, .stamina-bar-outer, .ultimate-bar-outer { height: 25px; background: rgba(0,0,0,0.8); border: 2px solid #555; border-radius: 12px; overflow: hidden; }
        .stamina-bar-outer { height: 8px; margin-top: 3px; }
        .ultimate-bar-outer { height: 8px; margin-top: 5px; }
        .health-bar-inner { height: 100%; transition: width 0.2s; }
        .health-bar-inner.player { background: linear-gradient(90deg, #00ff88, #00cc66); }
        .health-bar-inner.enemy { background: linear-gradient(90deg, #ff0844, #ff6b9d); }
        .stamina-bar-inner { height: 100%; background: linear-gradient(90deg, #00ff88, #00aa66); width: 100%; transition: width 0.1s; }
        .ultimate-bar-inner { height: 100%; background: linear-gradient(90deg, #ffd700, #ffaa00); width: 0%; transition: width 0.2s; }
        
        .moves-bar { display: grid; grid-template-columns: repeat(8, 1fr); gap: 6px; max-width: 1200px; margin: 5px auto; }
        .move-slot { background: rgba(20,20,20,0.9); border: 1px solid #555; border-radius: 6px; padding: 6px; text-align: center; transition: 0.2s; }
        .move-slot.cooldown { opacity: 0.4; }
        .move-slot.ready-ult { border-color: #ffd700; box-shadow: 0 0 15px rgba(255, 215, 0, 0.4); animation: pulse 1s infinite; }
        .move-slot.active { border-color: #00ff88; box-shadow: 0 0 15px rgba(0, 255, 136, 0.6); }
        .move-name { font-weight: bold; font-size: 0.75em; }
        .move-slot-key { font-size: 0.65em; color: #999; background: #000; padding: 2px 5px; border-radius: 4px; margin-top: 2px; }
        
        .controls-footer { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); padding: 12px 30px; border-radius: 10px; border: 1px solid #555; font-size: 0.85em; }
        .controls-footer span { margin: 0 10px; color: #aaa; }
        .controls-footer b { color: #ff0844; }
        
        .combo-display { font-size: 2.5em; font-weight: 900; color: #ffd700; text-shadow: 0 0 15px #ffd700; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); animation: comboPulse 0.3s; pointer-events: none; display: none; }
        @keyframes comboPulse { 0% { transform: translate(-50%, -50%) scale(0.5); } 50% { transform: translate(-50%, -50%) scale(1.2); } 100% { transform: translate(-50%, -50%) scale(1); } }
        
        /* Overlays */
        #shopScreen, #gameOver, #domainOverlay { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(10, 0, 5, 0.98); border: 4px solid #ff0844; border-radius: 20px; padding: 40px; z-index: 100; text-align: center; }
        #domainOverlay { width: 100vw; height: 100vh; background: transparent; border: none; pointer-events: none; z-index: 50; align-items: center; justify-content: center; }
        #domainText { font-family: 'Orbitron'; font-size: 5em; font-weight: 900; color: #fff; text-shadow: 0 0 30px currentColor; opacity: 0; animation: domainFlash 3s forwards; }
        
        button { font-family: 'Orbitron'; font-size: 1.2em; padding: 12px 35px; background: linear-gradient(135deg, #ff0844, #aa0000); border: 2px solid #fff; color: white; cursor: pointer; clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%); margin: 10px; transition: 0.2s; }
        button:hover { transform: scale(1.1); filter: brightness(1.2); }
        button.secondary { background: linear-gradient(135deg, #333, #555); }
        
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes pulse { 0% { border-color: #ffd700; } 50% { border-color: #fff; } 100% { border-color: #ffd700; } }
        @keyframes domainFlash { 0% { opacity: 0; transform: scale(0.5); } 20% { opacity: 1; transform: scale(1.2); } 80% { opacity: 1; transform: scale(1); } 100% { opacity: 0; transform: scale(1.5); } }
    </style>
</head>
<body>
    <canvas id="bgCanvas"></canvas>
    
    <!-- Loading Screen -->
    <div id="loadingScreen">
        <h2>LOADING CURSED ENERGY...</h2>
    </div>
    
    <div class="container">
        <!-- Mode Selection -->
        <div id="modeScreen" style="display:none;">
            <h1 class="title">JUJUTSU KAISEN</h1>
            <p style="font-size: 1.5em; color: #aaa; margin-bottom: 40px;">DOMAIN CLASH</p>
            <div class="modes-grid" id="modesContainer"></div>
        </div>

        <!-- Character Selection -->
        <div id="selectionScreen">
            <h2 style="font-size: 2em; color: #ff0844; margin-bottom: 10px;" id="selectionTitle">SELECT CHARACTER</h2>
            <div class="characters-grid" id="charactersContainer"></div>
            <button onclick="confirmSelection()">CONTINUE</button>
            <button class="secondary" onclick="backToModes()">BACK</button>
        </div>

        <!-- Map Selection -->
        <div id="mapScreen">
            <h2 style="font-size: 2em; color: #ff0844; margin-bottom: 20px;">SELECT BATTLEFIELD</h2>
            <div class="maps-grid" id="mapsContainer"></div>
            <button onclick="startBattle()">START BATTLE</button>
            <button class="secondary" onclick="backToSelection()">BACK</button>
        </div>

        <!-- Game Screen -->
        <div id="gameScreen">
            <div id="domainOverlay"><div id="domainText">DOMAIN EXPANSION</div></div>
            <div id="comboDisplay" class="combo-display"></div>

            <div class="hud">
                <div class="top-hud">
                    <div class="round-info" id="roundInfo">ROUND 1</div>
                    <div class="coins-display" id="coinsDisplay">üí∞ 0</div>
                </div>
                <div class="health-bars" id="healthBarsContainer"></div>
                <div class="moves-bar" id="movesBar"></div>
            </div>
            <canvas id="gameCanvas" width="1200" height="600"></canvas>
            
            <div class="controls-footer">
                <span><b>WASD</b>: Move</span>
                <span><b>SHIFT</b>: Block/Parry</span>
                <span><b>SPACE</b>: Dodge</span>
                <span><b>J/K/L/;/'</b>: Attacks</span>
                <span><b>U/I/O</b>: Specials</span>
                <span><b>P</b>: Ultimate</span>
            </div>
        </div>

        <!-- Shop -->
        <div id="shopScreen">
            <h2>üí∞ CURSED ENERGY SHOP</h2>
            <div id="shopItems" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin: 20px 0;"></div>
            <button onclick="closeShop()">NEXT BATTLE</button>
        </div>

        <!-- Game Over -->
        <div id="gameOver">
            <h2 id="gameOverTitle">EXORCISED</h2>
            <p id="gameOverText" style="margin: 20px 0; font-size: 1.2em;"></p>
            <button onclick="location.reload()">MAIN MENU</button>
        </div>
    </div>

<script>
// ========== GAME VARIABLES ==========
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const bgCanvas = document.getElementById('bgCanvas');

let CHARACTERS = [];
let MAPS = [];
let SHOP_ITEMS = [];

let gameMode = null;
let gameActive = false;
let selectedChars = [];
let selectedMap = null;
let fighters = [];
let projectiles = [];
let effects = [];
let particles = [];
let keys = {};

let currentRound = 1;
let coins = 0;

let playerStats = {
    maxHealth: 0,
    damageMultiplier: 1,
    speedBoost: 0,
    cooldownReduction: 0,
    lifesteal: 0,
    damageReduction: 0
};

// ========== LOAD JSON DATA ==========
async function loadGameData() {
    try {
        const [charactersRes, mapsRes, shopRes] = await Promise.all([
            fetch('characters-sample.json'), // Use the sample file we created
            fetch('maps.json'),
            fetch('shop.json')
        ]);
        
        CHARACTERS = await charactersRes.json();
        MAPS = await mapsRes.json();
        SHOP_ITEMS = await shopRes.json();
        
        console.log(`‚úÖ Loaded ${CHARACTERS.length} characters, ${MAPS.length} maps, ${SHOP_ITEMS.length} shop items`);
        
        // Hide loading screen and show mode selection
        document.getElementById('loadingScreen').style.display = 'none';
        document.getElementById('modeScreen').style.display = 'flex';
        
        initializeGame();
    } catch (error) {
        console.error('‚ùå Error loading game data:', error);
        document.getElementById('loadingScreen').innerHTML = '<h2 style="color: #ff0000;">ERROR: Could not load game data!<br><br>Make sure characters-sample.json, maps.json, and shop.json are in the same folder as this HTML file.</h2>';
    }
}

// Start loading immediately
loadGameData();

// ========== INITIALIZE GAME ==========
function initializeGame() {
    populateModes();
    setupInputHandlers();
    console.log('üéÆ Game initialized!');
}

function populateModes() {
    const container = document.getElementById('modesContainer');
    const modes = [
        { id: '1v1', name: '1v1 DUEL', icon: '‚öîÔ∏è', desc: 'Single battle to the death' },
        { id: '2v2', name: '2v2 CO-OP', icon: 'ü§ù', desc: 'Team up against enemies' },
        { id: 'tournament', name: 'TOURNAMENT', icon: 'üèÜ', desc: 'Fight through the bracket' },
        { id: 'endless', name: 'ENDLESS', icon: '‚ôæÔ∏è', desc: 'Survive as long as you can' },
        { id: 'survival', name: 'SURVIVAL', icon: 'üíÄ', desc: 'Progressive difficulty' }
    ];
    
    modes.forEach(mode => {
        const card = document.createElement('div');
        card.className = 'mode-card';
        card.onclick = () => selectMode(mode.id);
        card.innerHTML = `
            <div class="mode-icon">${mode.icon}</div>
            <div class="mode-name">${mode.name}</div>
            <div class="mode-desc">${mode.desc}</div>
        `;
        container.appendChild(card);
    });
}

// ========== FIGHTER CLASS WITH KNOCKBACK ==========
class Fighter {
    constructor(x, y, charData, isPlayer, playerNumber = 1) {
        this.x = x;
        this.y = y;
        this.width = 50;
        this.height = 80;
        this.char = charData;
        this.isPlayer = isPlayer;
        this.playerNumber = playerNumber;
        
        this.maxHealth = isPlayer ? 100 : 100;
        this.health = this.maxHealth;
        this.speed = charData.speed || 6;
        
        // Movement
        this.vx = 0;
        this.vy = 0;
        this.facing = isPlayer ? 1 : -1;
        this.onGround = true;
        
        // Combat
        this.cooldowns = {};
        Object.keys(charData.moves).forEach(key => this.cooldowns[key] = 0);
        this.buffs = {};
        this.stunned = 0;
        this.invuln = 0;
        this.ultimateCharge = 0;
        
        // NEW: Stamina System
        this.maxStamina = 100;
        this.stamina = 100;
        this.staminaRegen = 0.5;
        
        // NEW: Defense System
        this.blocking = false;
        this.parryWindow = 0;
        this.parrySuccessTime = 0;
        
        // NEW: Combo & Knockback System
        this.combo = 0;
        this.lastAttackTime = 0;
        this.hitstun = 0;
        this.knockbackX = 0; // NEW: Horizontal knockback velocity
        this.knockbackY = 0; // NEW: Vertical knockback velocity
    }

    update() {
        // Hitstun prevents all actions
        if (this.hitstun > 0) {
            this.hitstun--;
            // Apply knockback during hitstun
            this.x += this.knockbackX;
            this.y += this.knockbackY;
            
            // Decay knockback
            this.knockbackX *= 0.85;
            this.knockbackY *= 0.85;
            
            // Stop small knockback
            if (Math.abs(this.knockbackX) < 0.5) this.knockbackX = 0;
            if (Math.abs(this.knockbackY) < 0.5) this.knockbackY = 0;
            
            return;
        }
        
        // Stun prevents actions
        if (this.stunned > 0) {
            this.stunned--;
            return;
        }

        // Update timers
        if (this.invuln > 0) this.invuln--;
        if (this.parryWindow > 0) this.parryWindow--;
        if (this.parrySuccessTime > 0) this.parrySuccessTime--;
        
        // Stamina regeneration
        if (!this.blocking && this.stamina < this.maxStamina) {
            this.stamina = Math.min(this.maxStamina, this.stamina + this.staminaRegen);
        }
        
        // Blocking stamina drain
        if (this.blocking && this.stamina > 0) {
            this.stamina = Math.max(0, this.stamina - 0.3);
            if (this.stamina === 0) {
                this.blocking = false;
                this.stunned = 30;
                spawnText(this.x, this.y, "GUARD BREAK!", "#ff0000");
            }
        }
        
        // Buff timers
        for (let key in this.buffs) {
            this.buffs[key]--;
            if (this.buffs[key] <= 0) delete this.buffs[key];
        }
        
        // Cooldowns
        for (let key in this.cooldowns) {
            if (this.cooldowns[key] > 0) this.cooldowns[key]--;
        }

        // Movement (slower when blocking)
        this.x += this.vx * (this.blocking ? 0.3 : 1);
        this.y += this.vy;
        
        // Gravity
        if (!this.onGround) {
            this.vy += 0.8;
        } else {
            this.vy = 0;
        }
        
        // Ground collision
        const groundY = canvas.height - this.height - 20;
        if (this.y >= groundY) {
            this.y = groundY;
            this.onGround = true;
            this.knockbackY = 0; // Stop vertical knockback on ground
        } else {
            this.onGround = false;
        }
        
        // Boundaries (with knockback consideration)
        this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
        if (this.x === 0 || this.x === canvas.width - this.width) {
            this.knockbackX = 0; // Stop horizontal knockback at walls
        }
        this.y = Math.max(0, this.y);
        
        // Combo reset
        if (Date.now() - this.lastAttackTime > 2000) {
            this.combo = 0;
        }
    }

    draw() {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.beginPath();
        ctx.ellipse(this.x + this.width/2, canvas.height - 15, 25, 10, 0, 0, Math.PI*2);
        ctx.fill();

        // Body
        ctx.fillStyle = this.char.color;
        if (this.invuln > 0 && Math.floor(Date.now() / 100) % 2 === 0) ctx.fillStyle = '#fff';
        if (this.parrySuccessTime > 0) ctx.fillStyle = '#ffd700';
        
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.char.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.shadowBlur = 0;

        // Icon
        ctx.font = '30px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(this.char.icon, this.x + this.width/2, this.y + 40);

        // Status indicators
        if (this.stunned > 0 || this.hitstun > 0) {
            ctx.font = '20px Arial';
            ctx.fillText('üí´', this.x + this.width/2, this.y - 10);
        }
        
        // Block/Shield indicator
        if (this.buffs.shield || this.blocking) {
            ctx.strokeStyle = this.blocking ? '#4169e1' : '#00ffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x + this.width/2, this.y + this.height/2, 50, 0, Math.PI*2);
            ctx.stroke();
            
            if (this.parryWindow > 0) {
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + this.height/2, 55, 0, Math.PI*2);
                ctx.stroke();
            }
        }
    }

    takeDamage(amount, attacker, moveData = {}) {
        // PARRY CHECK
        if (this.parryWindow > 0) {
            this.parrySuccessTime = 30;
            spawnText(this.x, this.y, "‚ö° PARRY!", "#ffd700");
            
            if (attacker) {
                attacker.stunned = 60;
                attacker.takeDamage(amount * 0.5, this);
            }
            
            if (this.isPlayer) {
                this.ultimateCharge = Math.min(100, this.ultimateCharge + 15);
            }
            return 0;
        }
        
        // Invulnerability
        if (this.invuln > 0) {
            spawnText(this.x, this.y, "MISS", "#ccc");
            return 0;
        }
        
        // Blocking
        if (this.blocking && this.stamina > 0) {
            amount *= 0.3;
            this.stamina = Math.max(0, this.stamina - 10);
            spawnText(this.x, this.y, "üõ°Ô∏è BLOCKED", "#4169e1");
            
            if (this.stamina === 0) {
                this.blocking = false;
                this.stunned = 30;
                spawnText(this.x, this.y, "üí• GUARD BREAK!", "#ff0000");
            }
        }
        
        // Shield buff
        if (this.buffs.shield) {
            spawnText(this.x, this.y, "SHIELD", "#00ffff");
            return 0;
        }
        
        // Apply damage
        this.health -= amount;
        if (this.health < 0) this.health = 0;
        spawnText(this.x, this.y, Math.floor(amount), "#ff0000");
        
        // NEW: Apply knockback from move
        if (moveData.knockback && attacker) {
            const direction = (this.x > attacker.x) ? 1 : -1;
            this.knockbackX = direction * (moveData.knockback / 10);
            
            // Vertical knockback for launchers
            if (moveData.launch) {
                this.knockbackY = -8;
                this.onGround = false;
            }
        }
        
        // Apply hitstun
        if (moveData.hitstun) {
            this.hitstun = moveData.hitstun;
        }
        
        // Attacker gains combo and ult charge
        if (attacker && attacker.isPlayer) {
            attacker.combo++;
            attacker.lastAttackTime = Date.now();
            attacker.ultimateCharge = Math.min(100, attacker.ultimateCharge + 3);
        }
        
        return amount;
    }

    startBlock() {
        if (this.stamina > 10 && !this.stunned && !this.hitstun) {
            this.blocking = true;
            this.parryWindow = 10;
        }
    }
    
    stopBlock() {
        this.blocking = false;
        this.parryWindow = 0;
    }

    attack(moveType) {
        if (this.stunned > 0 || this.hitstun > 0 || this.cooldowns[moveType] > 0) return;
        
        const move = this.char.moves[moveType];
        if (!move) return;
        
        // Stamina cost
        const staminaCost = moveType === 'light' ? 5 : moveType === 'heavy' ? 15 : 20;
        if (this.stamina < staminaCost) return;
        this.stamina -= staminaCost;

        // Ultimate check
        if (moveType === 'ultimate') {
            if (this.ultimateCharge < 100) return;
            this.ultimateCharge = 0;
        }

        // Set cooldown
        this.cooldowns[moveType] = (move.cd || 1) * 60;

        // Execute move
        const targets = fighters.filter(f => f.isPlayer !== this.isPlayer && f.health > 0);
        targets.forEach(target => {
            const distance = Math.abs(target.x - this.x);
            const moveRange = move.range || 100;
            
            if (distance < moveRange) {
                target.takeDamage(move.dmg, this, move);
            }
        });
        
        // Gain ult charge
        if (moveType !== 'ultimate') {
            this.ultimateCharge = Math.min(100, this.ultimateCharge + (moveType === 'light' ? 5 : 12));
        }
    }
}

// ========== UTILITY FUNCTIONS ==========
function spawnText(x, y, text, color) {
    // Simple text display (implement particles later)
    console.log(`${text} at (${x}, ${y})`);
}

// ========== MODE SELECTION ==========
function selectMode(mode) {
    gameMode = mode;
    document.getElementById('modeScreen').style.display = 'none';
    document.getElementById('selectionScreen').style.display = 'flex';
    populateCharacters();
}

function populateCharacters() {
    const container = document.getElementById('charactersContainer');
    container.innerHTML = '';
    
    CHARACTERS.forEach(char => {
        const card = document.createElement('div');
        card.className = 'character-card';
        card.onclick = () => selectCharacter(char);
        card.innerHTML = `
            <div class="character-portrait">${char.icon}</div>
            <div class="character-name">${char.name}</div>
            <div class="character-title">${char.title}</div>
        `;
        container.appendChild(card);
    });
}

function selectCharacter(char) {
    selectedChars.push(char);
    console.log('Selected:', char.name);
    confirmSelection();
}

function confirmSelection() {
    if (selectedChars.length > 0) {
        document.getElementById('selectionScreen').style.display = 'none';
        document.getElementById('mapScreen').style.display = 'flex';
        populateMaps();
    }
}

function populateMaps() {
    const container = document.getElementById('mapsContainer');
    container.innerHTML = '';
    
    MAPS.forEach(map => {
        const card = document.createElement('div');
        card.className = 'map-card';
        card.onclick = () => selectMap(map);
        card.innerHTML = `
            <div class="map-preview">${map.icon}</div>
            <div class="map-name">${map.name}</div>
        `;
        container.appendChild(card);
    });
}

function selectMap(map) {
    selectedMap = map;
    document.querySelectorAll('.map-card').forEach(c => c.classList.remove('selected'));
    event.target.closest('.map-card').classList.add('selected');
}

function startBattle() {
    if (!selectedMap) {
        alert('Please select a map!');
        return;
    }
    
    document.getElementById('mapScreen').style.display = 'none';
    document.getElementById('gameScreen').style.display = 'block';
    
    // Set map colors
    bgCanvas.style.background = selectedMap.bgColor;
    
    // Create fighters
    fighters = [
        new Fighter(200, canvas.height - 100, selectedChars[0], true),
        new Fighter(800, canvas.height - 100, CHARACTERS[1], false)
    ];
    
    gameActive = true;
    gameLoop();
}

function backToModes() {
    selectedChars = [];
    document.getElementById('selectionScreen').style.display = 'none';
    document.getElementById('modeScreen').style.display = 'flex';
}

function backToSelection() {
    selectedMap = null;
    document.getElementById('mapScreen').style.display = 'none';
    document.getElementById('selectionScreen').style.display = 'flex';
}

// ========== INPUT HANDLING ==========
function setupInputHandlers() {
    document.addEventListener('keydown', (e) => {
        keys[e.key.toLowerCase()] = true;
        
        if (!gameActive || fighters.length === 0) return;
        
        const player = fighters.find(f => f.isPlayer);
        if (!player) return;
        
        // Attacks
        if (e.key === 'j') player.attack('light');
        if (e.key === 'k') player.attack('heavy');
        if (e.key === 'l') player.attack('sweep');
        if (e.key === ';') player.attack('antiair');
        if (e.key === "'") player.attack('lunge');
        if (e.key === 'u') player.attack('special1');
        if (e.key === 'i') player.attack('special2');
        if (e.key === 'o') player.attack('support');
        if (e.key === 'p') player.attack('ultimate');
        
        // Block
        if (e.key === 'Shift') player.startBlock();
        
        // Dodge
        if (e.key === ' ') {
            player.invuln = 12;
            player.stamina = Math.max(0, player.stamina - 20);
        }
    });
    
    document.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
        
        if (e.key === 'Shift' && fighters.length > 0) {
            const player = fighters.find(f => f.isPlayer);
            if (player) player.stopBlock();
        }
    });
}

// ========== GAME LOOP ==========
function gameLoop() {
    if (!gameActive) return;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Update and draw fighters
    fighters.forEach(f => {
        // Player movement
        if (f.isPlayer && !f.stunned && !f.hitstun) {
            f.vx = 0;
            if (keys['a']) f.vx = -f.speed;
            if (keys['d']) f.vx = f.speed;
            if (keys['w'] && f.onGround) {
                f.vy = -15;
                f.onGround = false;
            }
        }
        
        // Basic AI
        if (!f.isPlayer) {
            const target = fighters.find(t => t.isPlayer && t.health > 0);
            if (target) {
                const distance = Math.abs(target.x - f.x);
                if (distance > 100) {
                    f.vx = (target.x > f.x) ? f.speed : -f.speed;
                } else {
                    f.vx = 0;
                    if (Math.random() < 0.02) {
                        const moves = ['light', 'heavy', 'special1'];
                        f.attack(moves[Math.floor(Math.random() * moves.length)]);
                    }
                }
            }
        }
        
        f.update();
        f.draw();
    });
    
    // Check win condition
    const playerAlive = fighters.some(f => f.isPlayer && f.health > 0);
    const enemyAlive = fighters.some(f => !f.isPlayer && f.health > 0);
    
    if (!playerAlive || !enemyAlive) {
        gameActive = false;
        const winner = playerAlive ? 'VICTORY!' : 'DEFEAT!';
        document.getElementById('gameOverTitle').textContent = winner;
        document.getElementById('gameOver').style.display = 'block';
    }
    
    requestAnimationFrame(gameLoop);
}

function closeShop() {
    document.getElementById('shopScreen').style.display = 'none';
}

</script>
</body>
</html>
