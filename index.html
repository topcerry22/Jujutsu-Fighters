<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JUJUTSU KAISEN: DOMAIN CLASH</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Rajdhani', sans-serif; background: #050505; color: #fff; overflow: hidden; user-select: none; }
        #bgCanvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; transition: background 0.5s; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        
        /* Selection Screen */
        #selectionScreen { min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; animation: fadeIn 0.5s ease; }
        .title { font-family: 'Orbitron', sans-serif; font-size: 4em; font-weight: 900; letter-spacing: 6px; margin-bottom: 10px; background: linear-gradient(135deg, #ff0844, #ffb199, #ff0844); -webkit-background-clip: text; -webkit-text-fill-color: transparent; animation: titleGlow 2s ease-in-out infinite; text-align: center; }
        @keyframes titleGlow { 0%, 100% { filter: drop-shadow(0 0 20px rgba(255, 8, 68, 0.5)); } 50% { filter: drop-shadow(0 0 40px rgba(255, 8, 68, 0.8)); } }
        
        .characters-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px; width: 100%; max-width: 1200px; max-height: 65vh; overflow-y: auto; padding: 20px; background: rgba(20, 0, 10, 0.8); border: 2px solid rgba(255, 8, 68, 0.3); border-radius: 20px; backdrop-filter: blur(10px); }
        .character-card { background: linear-gradient(135deg, rgba(30, 10, 20, 0.95), rgba(50, 10, 30, 0.95)); border: 1px solid rgba(255, 8, 68, 0.3); border-radius: 12px; padding: 15px; cursor: pointer; transition: 0.2s; text-align: center; position: relative; overflow: hidden; }
        .character-card:hover { transform: translateY(-5px); border-color: #ff0844; box-shadow: 0 5px 20px rgba(255, 8, 68, 0.4); }
        .character-card.locked { opacity: 0.5; filter: grayscale(1); pointer-events: none; }
        .character-portrait { font-size: 3em; margin-bottom: 5px; }
        .character-name { font-weight: 900; font-size: 1.1em; color: #ff0844; margin-bottom: 2px; }
        .character-title { font-size: 0.75em; color: #aaa; font-style: italic; }
        .domain-badge { position: absolute; top: 5px; right: 5px; font-size: 0.7em; background: #ffd700; color: #000; padding: 2px 6px; border-radius: 4px; font-weight: bold; }

        /* Game Screen */
        #gameScreen { display: none; width: 100%; height: 100vh; position: relative; }
        #gameCanvas { display: block; width: 1200px; height: 600px; background: rgba(0,0,0,0.5); border: 4px solid #333; margin: 0 auto; box-shadow: 0 0 60px rgba(0,0,0,0.5); border-radius: 10px; }
        
        .hud { width: 1200px; margin: 10px auto; }
        .top-hud { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .round-info, .coins-display { font-size: 1.5em; font-weight: 900; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.5); }
        
        .health-bars { display: flex; justify-content: space-between; gap: 40px; margin-bottom: 10px; }
        .health-group { flex: 1; }
        .health-label { font-size: 1.2em; font-weight: 900; margin-bottom: 5px; display: flex; justify-content: space-between; text-shadow: 2px 2px 0 #000; }
        .health-bar-outer { height: 25px; background: rgba(0,0,0,0.8); border: 2px solid #555; border-radius: 12px; overflow: hidden; position: relative; }
        .health-bar-inner { height: 100%; transition: width 0.2s; }
        .health-bar-inner.player { background: linear-gradient(90deg, #00ff88, #00cc66); }
        .health-bar-inner.enemy { background: linear-gradient(90deg, #ff0844, #ff6b9d); }
        .ultimate-bar-outer { height: 8px; background: #222; margin-top: 5px; border-radius: 4px; overflow: hidden; }
        .ultimate-bar-inner { height: 100%; background: linear-gradient(90deg, #ffd700, #ffaa00); width: 0%; transition: width 0.2s; }

        .moves-bar { display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; max-width: 1200px; margin: 5px auto; }
        .move-slot { background: rgba(20,20,20,0.9); border: 1px solid #555; border-radius: 6px; padding: 8px; text-align: center; position: relative; transition: 0.2s; }
        .move-slot.cooldown { border-color: #555; opacity: 0.4; background: #000; }
        .move-slot.ready-ult { border-color: #ffd700; box-shadow: 0 0 15px rgba(255, 215, 0, 0.4); animation: pulse 1s infinite; }
        .move-slot-key { font-size: 0.7em; color: #999; background: #000; padding: 2px 6px; border-radius: 4px; display: inline-block; margin-top: 3px; font-family: monospace; }
        .move-name { font-weight: bold; font-size: 0.8em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* Overlays */
        #shopScreen, #gameOver, #tutorialOverlay, #domainOverlay { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(10, 0, 5, 0.98); border: 4px solid #ff0844; border-radius: 20px; padding: 40px; z-index: 100; text-align: center; box-shadow: 0 0 100px rgba(0,0,0,0.9); }
        #domainOverlay { width: 100vw; height: 100vh; background: transparent; border: none; pointer-events: none; z-index: 50; display: none; align-items: center; justify-content: center; }
        #domainText { font-family: 'Orbitron'; font-size: 5em; font-weight: 900; color: #fff; text-shadow: 0 0 30px currentColor; opacity: 0; animation: domainFlash 3s forwards; }
        
        #shopScreen { border-color: #ffd700; width: 800px; max-height: 80vh; overflow-y: auto; }
        .shop-items { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin: 20px 0; }
        .shop-item { border: 1px solid #ffd700; padding: 15px; cursor: pointer; border-radius: 10px; transition: 0.2s; background: rgba(255, 215, 0, 0.05); }
        .shop-item:hover { background: rgba(255, 215, 0, 0.2); transform: scale(1.02); }
        
        button { font-family: 'Orbitron'; font-size: 1.2em; padding: 12px 35px; background: linear-gradient(135deg, #ff0844, #aa0000); border: 2px solid #fff; color: white; cursor: pointer; clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%); margin-top: 20px; transition: 0.2s; }
        button:hover { transform: scale(1.1); filter: brightness(1.2); }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes pulse { 0% { border-color: #ffd700; } 50% { border-color: #fff; } 100% { border-color: #ffd700; } }
        @keyframes domainFlash { 0% { opacity: 0; transform: scale(0.5); } 20% { opacity: 1; transform: scale(1.2); } 80% { opacity: 1; transform: scale(1); } 100% { opacity: 0; transform: scale(1.5); } }
    </style>
</head>
<body>
    <canvas id="bgCanvas"></canvas>
    
    <div class="container">
        <div id="selectionScreen">
            <h1 class="title">JUJUTSU KAISEN</h1>
            <p class="subtitle">DOMAIN CLASH</p>
            <div class="characters-grid" id="charactersContainer"></div>
        </div>

        <div id="tutorialOverlay">
            <h2>CONTROLS</h2>
            <div style="text-align: left; margin: 20px; line-height: 1.8; color: #ccc; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px;">
                <p><b style="color:#ff0844">WASD</b> : Movement</p>
                <p><b style="color:#00bfff">J</b> : Light Attack (Fast, Low Dmg)</p>
                <p><b style="color:#00bfff">K</b> : Heavy Attack (Slow, High Dmg)</p>
                <p><b style="color:#ffd700">U / I</b> : Cursed Techniques (Special)</p>
                <p><b style="color:#00ff88">O</b> : Support / Buff / Dodge</p>
                <p><b style="color:#aa00ff">P</b> : DOMAIN EXPANSION (Ultimate)</p>
            </div>
            <button onclick="startGame(true)">TUTORIAL</button>
            <button onclick="startGame(false)" style="background: #333; margin-left: 10px;">BATTLE</button>
        </div>

        <div id="gameScreen">
            <div id="domainOverlay"><div id="domainText">DOMAIN EXPANSION</div></div>

            <div class="hud">
                <div class="top-hud">
                    <div class="round-info" id="roundInfo">ROUND 1</div>
                    <div class="coins-display" id="coinsDisplay">ðŸ’° 0</div>
                </div>
                <div class="health-bars">
                    <div class="health-group">
                        <div class="health-label"><span id="pName">Player</span> <span id="pHP">100/100</span></div>
                        <div class="health-bar-outer"><div class="health-bar-inner player" id="playerHealthBar" style="width: 100%"></div></div>
                        <div class="ultimate-bar-outer"><div class="ultimate-bar-inner" id="ultimateBar"></div></div>
                    </div>
                    <div class="health-group">
                        <div class="health-label"><span id="eName">Enemy</span> <span id="eHP">100/100</span></div>
                        <div class="health-bar-outer"><div class="health-bar-inner enemy" id="enemyHealthBar" style="width: 100%"></div></div>
                    </div>
                </div>
                <div class="moves-bar" id="movesBar"></div>
            </div>
            <canvas id="gameCanvas" width="1200" height="600"></canvas>
        </div>

        <div id="shopScreen">
            <h2>CURSED ENERGY SHOP</h2>
            <div class="shop-items" id="shopItems"></div>
            <button onclick="closeShop()">NEXT BATTLE</button>
        </div>

        <div id="gameOver">
            <h2 id="gameOverTitle">EXORCISED</h2>
            <p id="gameOverText"></p>
            <button onclick="location.reload()">TRY AGAIN</button>
        </div>
    </div>

<script>
    // --- 1. CHARACTERS DATABASE ---
    // Added 9 new characters for a total of 14
    const CHARACTERS = [
        // EXISTING
        { id: 'gojo', name: 'SATORU GOJO', title: 'The Strongest', icon: 'ðŸ‘ï¸', color: '#00bfff', domainColor: '#0a0a2a', speed: 6.5, moves: { light: { name: 'Martial Arts', dmg: 8, cd: 0.3, type: 'melee', color: '#00bfff' }, heavy: { name: 'Infinity Strike', dmg: 20, cd: 1.5, type: 'melee', range: 100, color: '#0088ff' }, special1: { name: 'Cursed Blue', dmg: 35, cd: 4, type: 'projectile', color: '#0066ff', pull: true }, special2: { name: 'Reversal Red', dmg: 50, cd: 6, type: 'projectile', knockback: 150, color: '#ff0033' }, support: { name: 'Infinity', cd: 12, type: 'buff', shield: true, duration: 3, color: '#fff' }, ultimate: { name: 'UNLIMITED VOID', dmg: 20, type: 'domain', effect: 'stun', duration: 4, color: '#ffffff' } } },
        { id: 'sukuna', name: 'RYOMEN SUKUNA', title: 'King of Curses', icon: 'ðŸ‘¹', color: '#ff0033', domainColor: '#2a0a0a', speed: 6, moves: { light: { name: 'Slash', dmg: 10, cd: 0.3, type: 'melee', color: '#ff0033' }, heavy: { name: 'Cleave', dmg: 28, cd: 1.5, type: 'melee', slash: true, color: '#cc0000' }, special1: { name: 'Dismantle', dmg: 40, cd: 5, type: 'projectile', multi: 3, color: '#990000' }, special2: { name: 'Divine Flame', dmg: 60, cd: 8, type: 'projectile', burn: true, color: '#ff6600' }, support: { name: 'Domain Amp', cd: 12, type: 'buff', damageBoost: 1.5, duration: 4, color: '#aa0000' }, ultimate: { name: 'MALEVOLENT SHRINE', dmg: 250, type: 'domain', effect: 'dot', color: '#660000' } } },
        { id: 'yuji', name: 'YUJI ITADORI', title: 'The Tiger', icon: 'ðŸ¥Š', color: '#ff6b00', speed: 7.5, moves: { light: { name: 'Quick Jab', dmg: 8, cd: 0.2, type: 'melee', color: '#ff6b00' }, heavy: { name: 'Divergent Fist', dmg: 22, cd: 1.2, type: 'melee', hits: 2, color: '#ff4400' }, special1: { name: 'Manji Kick', dmg: 35, cd: 4, type: 'melee', knockback: 120, color: '#ff8800' }, special2: { name: 'Black Flash', dmg: 70, cd: 8, type: 'melee', crit: true, color: '#000' }, support: { name: 'Focus', cd: 10, type: 'buff', speedBoost: 1.5, duration: 5, color: '#fff' }, ultimate: { name: 'RAGE MODE', dmg: 0, type: 'buff', damageBoost: 3, duration: 8, color: '#ff0000' } } },
        { id: 'megumi', name: 'MEGUMI FUSHIGURO', title: 'Ten Shadows', icon: 'ðŸº', color: '#4a5568', domainColor: '#1a202c', speed: 6, moves: { light: { name: 'Strike', dmg: 7, cd: 0.3, type: 'melee', color: '#4a5568' }, heavy: { name: 'Shadow Hit', dmg: 18, cd: 1.5, type: 'melee', color: '#2d3748' }, special1: { name: 'Divine Dog', dmg: 30, cd: 6, type: 'summon', color: '#000' }, special2: { name: 'Nue', dmg: 40, cd: 7, type: 'projectile', stun: 1, color: '#ffd700' }, support: { name: 'Rabbit Escape', cd: 10, type: 'dodge', invuln: 2, color: '#fff' }, ultimate: { name: 'CHIMERA SHADOW GARDEN', dmg: 150, type: 'domain', effect: 'summon_swarm', color: '#1a202c' } } },
        { id: 'nobara', name: 'NOBARA KUGISAKI', title: 'Straw Doll', icon: 'ðŸ”¨', color: '#ff69b4', speed: 5.5, moves: { light: { name: 'Nail', dmg: 9, cd: 0.3, type: 'melee', color: '#ff69b4' }, heavy: { name: 'Hammer', dmg: 24, cd: 1.5, type: 'melee', stun: 0.5, color: '#ff1493' }, special1: { name: 'Hairpin', dmg: 35, cd: 4, type: 'projectile', color: '#dc143c' }, special2: { name: 'Resonance', dmg: 50, cd: 7, type: 'delayed', delay: 1, color: '#c71585' }, support: { name: 'Straw Doll', cd: 9, type: 'buff', damageBoost: 1.3, duration: 5, color: '#ff1493' }, ultimate: { name: 'MAXIMUM OUTPUT', dmg: 140, type: 'beam', color: '#ff0066' } } },

        // NEW CHARACTERS
        { id: 'yuta', name: 'YUTA OKKOTSU', title: 'Special Grade', icon: 'ðŸ’', color: '#ffffff', domainColor: '#ffccff', speed: 6.5, moves: { light: { name: 'Katana Slash', dmg: 10, cd: 0.3, type: 'melee', color: '#eee' }, heavy: { name: 'Rika Strike', dmg: 30, cd: 2, type: 'melee', range: 120, color: '#4a004a' }, special1: { name: 'Cursed Speech: Die', dmg: 40, cd: 6, type: 'aoe', range: 200, color: '#purple' }, special2: { name: 'Love Blast', dmg: 60, cd: 8, type: 'beam', color: '#ff69b4' }, support: { name: 'Reverse Cursed', cd: 15, type: 'heal', amount: 40, color: '#00ff00' }, ultimate: { name: 'AUTHENTIC MUTUAL LOVE', dmg: 200, type: 'domain', effect: 'swords', color: '#ffb6c1' } } },
        { id: 'maki', name: 'MAKI ZENIN', title: 'Heavenly Restriction', icon: 'ðŸ‘“', color: '#2e8b57', speed: 8.5, moves: { light: { name: 'Spear Jab', dmg: 12, cd: 0.2, type: 'melee', color: '#2e8b57' }, heavy: { name: 'Dragon Bone', dmg: 35, cd: 1.5, type: 'melee', knockback: 50, color: '#8b4513' }, special1: { name: 'Playful Cloud', dmg: 45, cd: 5, type: 'melee', hits: 3, color: '#ff0000' }, special2: { name: 'Rapid Slash', dmg: 20, cd: 4, type: 'teleport_attack', color: '#ccc' }, support: { name: 'Sense', cd: 8, type: 'dodge', invuln: 2.5, color: '#fff' }, ultimate: { name: 'SOUL SPLIT KATANA', dmg: 180, type: 'melee', range: 150, trueDamage: true, color: '#444' } } },
        { id: 'inumaki', name: 'TOGE INUMAKI', title: 'Cursed Speech', icon: 'ðŸ“¢', color: '#9370db', speed: 5.5, moves: { light: { name: 'Kick', dmg: 6, cd: 0.3, type: 'melee', color: '#9370db' }, heavy: { name: 'Explode', dmg: 25, cd: 2, type: 'aoe', range: 100, color: '#ffd700' }, special1: { name: 'Don\'t Move', dmg: 10, cd: 8, type: 'stun', duration: 2, color: '#000' }, special2: { name: 'Get Twisted', dmg: 50, cd: 7, type: 'projectile', color: '#800080' }, support: { name: 'Sleep', cd: 12, type: 'stun', duration: 1.5, color: '#aaa' }, ultimate: { name: 'BLAST AWAY', dmg: 150, type: 'beam', width: 200, color: '#fff' } } },
        { id: 'panda', name: 'PANDA', title: 'Cursed Corpse', icon: 'ðŸ¼', color: '#333', speed: 5, moves: { light: { name: 'Punch', dmg: 9, cd: 0.4, type: 'melee', color: '#fff' }, heavy: { name: 'Bear Hug', dmg: 25, cd: 1.8, type: 'melee', stun: 0.5, color: '#000' }, special1: { name: 'Gorilla Mode', dmg: 40, cd: 6, type: 'melee', knockback: 150, color: '#8b4513' }, special2: { name: 'Drumming Beat', dmg: 45, cd: 7, type: 'melee', color: '#a0522d' }, support: { name: 'Tank Up', cd: 10, type: 'buff', shield: true, duration: 4, color: '#333' }, ultimate: { name: 'TRICERATOPS MODE', dmg: 0, type: 'buff', damageBoost: 2, speedBoost: 1.5, duration: 8, color: '#2f4f4f' } } },
        { id: 'todo', name: 'AOI TODO', title: 'Boogie Woogie', icon: 'ðŸ‘', color: '#4169e1', speed: 6, moves: { light: { name: 'Jab', dmg: 9, cd: 0.3, type: 'melee', color: '#4169e1' }, heavy: { name: 'Stomp', dmg: 22, cd: 1.5, type: 'melee', color: '#000080' }, special1: { name: 'Boogie Woogie', dmg: 10, cd: 3, type: 'swap', color: '#ff69b4' }, special2: { name: 'Black Flash', dmg: 50, cd: 6, type: 'melee', crit: true, color: '#000' }, support: { name: 'Clap', cd: 5, type: 'swap', color: '#ff69b4' }, ultimate: { name: 'IQ 530,000', dmg: 120, type: 'teleport_blitz', hits: 10, color: '#4169e1' } } },
        { id: 'nanami', name: 'KENTO NANAMI', title: 'Ratio Technique', icon: 'ðŸ‘”', color: '#f4a460', speed: 6, moves: { light: { name: 'Chop', dmg: 10, cd: 0.3, type: 'melee', color: '#f4a460' }, heavy: { name: 'Ratio', dmg: 35, cd: 2, type: 'melee', critChance: 0.5, color: '#000' }, special1: { name: 'Collapse', dmg: 40, cd: 5, type: 'aoe', range: 120, color: '#deb887' }, special2: { name: 'Tie Loosen', dmg: 0, cd: 8, type: 'buff', damageBoost: 1.5, duration: 4, color: '#ffd700' }, support: { name: 'Overtime', cd: 15, type: 'buff', damageBoost: 2, duration: 5, color: '#ff4500' }, ultimate: { name: 'RATIO COLLAPSE', dmg: 160, type: 'melee', crit: true, range: 200, color: '#daa520' } } },
        { id: 'mahito', name: 'MAHITO', title: 'Self-Embodiment', icon: 'ðŸ§µ', color: '#708090', domainColor: '#2f4f4f', speed: 6.5, moves: { light: { name: 'Touch', dmg: 8, cd: 0.3, type: 'melee', color: '#708090' }, heavy: { name: 'Blade Arm', dmg: 24, cd: 1.5, type: 'melee', range: 100, color: '#c0c0c0' }, special1: { name: 'Soul Multiplicity', dmg: 30, cd: 4, type: 'projectile', multi: 2, color: '#483d8b' }, special2: { name: 'Body Repel', dmg: 40, cd: 6, type: 'aoe', knockback: 200, color: '#778899' }, support: { name: 'Shape Shift', cd: 8, type: 'dodge', invuln: 2, color: '#fff' }, ultimate: { name: 'SELF-EMBODIMENT OF PERFECTION', dmg: 200, type: 'domain', effect: 'instant_dmg', color: '#000000' } } },
        { id: 'jogo', name: 'JOGO', title: 'Disaster Flame', icon: 'ðŸŒ‹', color: '#8b0000', domainColor: '#4a0404', speed: 7, moves: { light: { name: 'Ember', dmg: 10, cd: 0.3, type: 'projectile', color: '#ff4500' }, heavy: { name: 'Lava Burst', dmg: 28, cd: 1.8, type: 'aoe', range: 100, color: '#8b0000' }, special1: { name: 'Ember Insects', dmg: 35, cd: 5, type: 'projectile', multi: 3, homing: true, color: '#ff8c00' }, special2: { name: 'Maximum Meteor', dmg: 70, cd: 10, type: 'aoe', delay: 1.5, range: 200, color: '#ffd700' }, support: { name: 'Heat Wave', cd: 12, type: 'buff', damageBoost: 1.4, duration: 5, color: '#ff4500' }, ultimate: { name: 'COFFIN OF THE IRON MOUNTAIN', dmg: 180, type: 'domain', effect: 'burn_dot', color: '#800000' } } },
        { id: 'toji', name: 'TOJI FUSHIGURO', title: 'Sorcerer Killer', icon: 'â›“ï¸', color: '#111', speed: 9, moves: { light: { name: 'Kick', dmg: 12, cd: 0.2, type: 'melee', color: '#333' }, heavy: { name: 'Split Soul', dmg: 30, cd: 1.5, type: 'melee', trueDamage: true, color: '#555' }, special1: { name: 'Inverted Spear', dmg: 40, cd: 5, type: 'melee', dispel: true, color: '#fff' }, special2: { name: 'Chain of Thousand', dmg: 35, cd: 6, type: 'melee', range: 300, color: '#888' }, support: { name: 'Invisible', cd: 10, type: 'dodge', invuln: 3, color: '#000' }, ultimate: { name: 'HEAVENLY RESTRICTION', dmg: 0, type: 'buff', speedBoost: 2, damageBoost: 2, duration: 10, color: '#1a1a1a' } } }
    ];

    const SHOP_ITEMS = [
        { id: 'health', name: 'Health Boost', icon: 'â¤ï¸', price: 50, effect: 'maxHealth', value: 25 },
        { id: 'damage', name: 'Power Up', icon: 'âš”ï¸', price: 75, effect: 'damageMultiplier', value: 0.15 },
        { id: 'speed', name: 'Speed Up', icon: 'âš¡', price: 60, effect: 'speedBoost', value: 1.2 },
        { id: 'cooldown', name: 'Rapid Tech', icon: 'â±ï¸', price: 100, effect: 'cooldownReduction', value: 0.1 },
        { id: 'lifesteal', name: 'Cursed Drain', icon: 'ðŸ©¸', price: 120, effect: 'lifesteal', value: 0.08 }
    ];

    // --- 2. GAME VARIABLES ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const bgCanvas = document.getElementById('bgCanvas');
    
    let gameActive = false;
    let selectedChar = null;
    let player, enemy;
    let projectiles = [];
    let effects = [];
    let particles = [];
    let supports = [];
    let keys = {};
    
    let currentRound = 1;
    let coins = 0;
    let ultimateCharge = 0;
    let domainActive = false;
    
    let playerStats = {
        maxHealth: 100,
        damageMultiplier: 1,
        speedBoost: 0,
        cooldownReduction: 0,
        lifesteal: 0
    };

    // --- 3. CLASSES ---
    class Fighter {
        constructor(x, y, charData, isPlayer) {
            this.x = x;
            this.y = y;
            this.width = 50;
            this.height = 80;
            this.char = charData;
            this.isPlayer = isPlayer;
            
            // Stats
            this.maxHealth = isPlayer ? (100 + playerStats.maxHealth) : (100 + (currentRound * 20));
            if (!isPlayer && currentRound % 5 === 0) this.maxHealth *= 1.8; // Boss HP
            this.health = this.maxHealth;
            this.speed = charData.speed + (isPlayer ? playerStats.speedBoost : 0);
            
            this.vx = 0;
            this.vy = 0;
            this.facing = isPlayer ? 1 : -1;
            
            this.cooldowns = { light: 0, heavy: 0, special1: 0, special2: 0, support: 0, ultimate: 0 };
            this.buffs = {};
            this.stunned = 0;
            this.invuln = 0;
        }

        update() {
            if (this.stunned > 0) {
                this.stunned--;
                return;
            }

            // Buff/Debuff Timers
            if (this.invuln > 0) this.invuln--;
            for (let key in this.buffs) {
                this.buffs[key]--;
                if (this.buffs[key] <= 0) delete this.buffs[key];
            }
            
            // Cooldowns
            for (let key in this.cooldowns) {
                if (this.cooldowns[key] > 0) this.cooldowns[key]--;
            }

            // Movement Physics
            let currentSpeed = this.speed;
            if (this.buffs.speedBoost) currentSpeed *= 1.5;
            
            this.x += this.vx * (this.buffs.speedBoost ? 1.5 : 1);
            this.y += this.vy * (this.buffs.speedBoost ? 1.5 : 1);
            
            // Boundaries
            this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
            this.y = Math.max(0, Math.min(canvas.height - this.height, this.y));
        }

        draw() {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.beginPath();
            ctx.ellipse(this.x + this.width/2, this.y + this.height, 20, 10, 0, 0, Math.PI*2);
            ctx.fill();

            // Body
            ctx.fillStyle = this.char.color;
            if (this.invuln > 0 && Math.floor(Date.now() / 100) % 2 === 0) ctx.fillStyle = '#fff'; 
            
            ctx.shadowBlur = 15;
            ctx.shadowColor = this.char.color;
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.shadowBlur = 0;

            // Icon
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(this.char.icon, this.x + this.width/2, this.y + 40);

            // Stunned Indicator
            if (this.stunned > 0) {
                ctx.font = '20px Arial';
                ctx.fillText('ðŸ’«', this.x + this.width/2, this.y - 10);
            }
            
            // Shield Indicator
            if (this.buffs.shield) {
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + this.height/2, 50, 0, Math.PI*2);
                ctx.stroke();
            }
        }

        takeDamage(amount) {
            if (this.invuln > 0) {
                spawnText(this.x, this.y, "MISS", "#ccc");
                return 0;
            }
            if (this.buffs.shield) {
                spawnText(this.x, this.y, "BLOCKED", "#00ffff");
                return 0;
            }
            
            this.health -= amount;
            if (this.health < 0) this.health = 0;
            spawnText(this.x, this.y, Math.floor(amount), "#ff0000");
            
            return amount;
        }

        attack(type) {
            if (this.stunned > 0 || this.cooldowns[type] > 0) return;
            
            const move = this.char.moves[type];
            if (!move) return;

            // Ultimate Check
            if (type === 'ultimate') {
                if (this.isPlayer && ultimateCharge < 100) return;
                if (this.isPlayer) ultimateCharge = 0;
            }

            // Set Cooldown (60 frames = 1 second approx)
            let cdReduction = this.isPlayer ? playerStats.cooldownReduction : 0;
            this.cooldowns[type] = (move.cd || 1) * 60 * (1 - cdReduction);

            // Execute Move Logic
            executeMove(this, this.isPlayer ? enemy : player, move);
            
            // Gain Ult Charge (Player only)
            if (this.isPlayer && type !== 'ultimate') {
                ultimateCharge = Math.min(100, ultimateCharge + (type === 'light' ? 5 : 12));
            }
        }
    }

    class Projectile {
        constructor(x, y, vx, vy, move, owner) {
            this.x = x; this.y = y; this.vx = vx; this.vy = vy;
            this.move = move; this.owner = owner;
            this.radius = 15;
            this.active = true;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            if (this.x < -100 || this.x > canvas.width + 100) this.active = false;
        }
        draw() {
            ctx.fillStyle = this.move.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
            ctx.fill();
            // Trail
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(this.x - this.vx*2, this.y - this.vy*2, this.radius/2, 0, Math.PI*2);
            ctx.fill();
        }
    }

    class VisualEffect {
        constructor(x, y, type, color, size) {
            this.x = x; this.y = y; this.type = type; this.color = color;
            this.life = 30;
            this.maxLife = 30;
            this.size = size || 40;
        }
        update() { this.life--; }
        draw() {
            const alpha = this.life / this.maxLife;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = this.color;
            
            if (this.type === 'impact') {
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size * (1-alpha), 0, Math.PI*2); ctx.fill();
            } else if (this.type === 'slash') {
                ctx.lineWidth = 5; ctx.strokeStyle = this.color;
                ctx.beginPath(); 
                ctx.moveTo(this.x - 30, this.y - 30); 
                ctx.lineTo(this.x + 30, this.y + 30); 
                ctx.stroke();
            } else if (this.type === 'beam') {
                ctx.fillRect(0, this.y - 50, canvas.width, 100);
            } else if (this.type === 'domain_bg') {
                ctx.globalAlpha = 0.3 * alpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            ctx.globalAlpha = 1;
        }
    }

    class DamageNumber {
        constructor(x, y, text, color) {
            this.x = x; this.y = y; this.text = text; this.color = color;
            this.life = 40;
        }
        update() { this.y -= 1; this.life--; }
        draw() {
            ctx.globalAlpha = this.life / 40;
            ctx.fillStyle = this.color;
            ctx.font = 'bold 24px Orbitron';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.strokeText(this.text, this.x, this.y);
            ctx.fillText(this.text, this.x, this.y);
            ctx.globalAlpha = 1;
        }
    }

    class SupportEntity {
        constructor(x, y, owner, color) {
            this.x = x; this.y = y; this.owner = owner; this.color = color;
            this.life = 180; // 3 seconds
            this.angle = 0;
        }
        update() {
            this.life--;
            this.angle += 0.1;
            // Orbit owner
            this.x = this.owner.x + this.owner.width/2 + Math.cos(this.angle) * 60;
            this.y = this.owner.y + this.owner.height/2 + Math.sin(this.angle) * 60;
            
            // Auto attack occasionally
            if (this.life % 60 === 0) {
                const target = this.owner.isPlayer ? enemy : player;
                projectiles.push(new Projectile(this.x, this.y, this.owner.isPlayer ? 10 : -10, 0, {dmg: 15, color: this.color}, this.owner));
            }
        }
        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.arc(this.x, this.y, 10, 0, Math.PI*2); ctx.fill();
        }
    }

    // --- 4. GAME LOGIC ---

    function init() {
        const container = document.getElementById('charactersContainer');
        CHARACTERS.forEach(char => {
            const card = document.createElement('div');
            card.className = 'character-card';
            
            // Add domain badge if character has a domain ultimate
            let domainBadge = '';
            if (char.moves.ultimate && char.moves.ultimate.type === 'domain') {
                domainBadge = `<div class="domain-badge">DOMAIN</div>`;
            }

            card.innerHTML = `
                ${domainBadge}
                <div class="character-portrait">${char.icon}</div>
                <div class="character-name">${char.name}</div>
                <div class="character-title">${char.title}</div>
            `;
            card.onclick = () => {
                selectedChar = char;
                document.getElementById('selectionScreen').style.display = 'none';
                document.getElementById('tutorialOverlay').style.display = 'block';
            };
            container.appendChild(card);
        });
        
        // Background Animation
        const bgCanvas = document.getElementById('bgCanvas');
        const bgCtx = bgCanvas.getContext('2d');
        bgCanvas.width = window.innerWidth;
        bgCanvas.height = window.innerHeight;
        const particles = Array(50).fill().map(() => ({
            x: Math.random() * bgCanvas.width,
            y: Math.random() * bgCanvas.height,
            vx: (Math.random() - 0.5), vy: (Math.random() - 0.5),
            size: Math.random() * 3
        }));
        
        function animateBg() {
            if(domainActive) {
                // Domain background is handled via CSS or solid color fill
                return requestAnimationFrame(animateBg);
            }
            bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
            bgCtx.fillStyle = 'rgba(255, 8, 68, 0.2)';
            particles.forEach(p => {
                p.x += p.vx; p.y += p.vy;
                if (p.x < 0 || p.x > bgCanvas.width) p.vx *= -1;
                if (p.y < 0 || p.y > bgCanvas.height) p.vy *= -1;
                bgCtx.beginPath(); bgCtx.arc(p.x, p.y, p.size, 0, Math.PI*2); bgCtx.fill();
            });
            requestAnimationFrame(animateBg);
        }
        animateBg();
    }

    function startGame(tutorial) {
        document.getElementById('tutorialOverlay').style.display = 'none';
        document.getElementById('gameScreen').style.display = 'block';
        
        player = new Fighter(100, 300, selectedChar, true);
        
        let enemyChar;
        if (tutorial) {
            enemyChar = { ...CHARACTERS[0], name: 'TRAINING DUMMY', moves: {} };
        } else {
            enemyChar = CHARACTERS[Math.floor(Math.random() * CHARACTERS.length)];
        }
        enemy = new Fighter(1000, 300, enemyChar, false);
        
        projectiles = [];
        effects = [];
        particles = [];
        supports = [];
        domainActive = false;
        document.getElementById('bgCanvas').style.background = '#050505';
        
        setupMovesUI();
        gameActive = true;
        gameLoop();
    }

    function setupMovesUI() {
        const bar = document.getElementById('movesBar');
        bar.innerHTML = '';
        const keysMap = ['J', 'K', 'U', 'I', 'O', 'P'];
        const types = ['light', 'heavy', 'special1', 'special2', 'support', 'ultimate'];
        
        types.forEach((type, i) => {
            const move = selectedChar.moves[type];
            const div = document.createElement('div');
            div.className = 'move-slot';
            div.id = `slot-${type}`;
            div.innerHTML = `
                <div class="move-name">${move.name}</div>
                <div class="move-slot-key">${keysMap[i]}</div>
            `;
            bar.appendChild(div);
        });
    }

    function triggerDomainExpansion(attacker, move) {
        domainActive = true;
        
        // Visuals
        const overlay = document.getElementById('domainOverlay');
        const overlayText = document.getElementById('domainText');
        
        overlayText.innerText = move.name;
        overlayText.style.color = move.color;
        overlay.style.display = 'flex';
        
        // Background change
        document.getElementById('bgCanvas').style.background = attacker.char.domainColor || move.color;
        
        // Hide overlay after animation
        setTimeout(() => {
            overlay.style.display = 'none';
        }, 2000);
        
        // Effect Logic
        if (move.effect === 'stun' || move.effect === 'void') {
            const target = attacker.isPlayer ? enemy : player;
            target.stunned = 240; // 4 seconds stun
            target.takeDamage(move.dmg);
        } else if (move.effect === 'dot' || move.effect === 'burn_dot') {
            // Damage over time (Sukuna/Jogo)
            let ticks = 0;
            const interval = setInterval(() => {
                if(!gameActive) clearInterval(interval);
                const target = attacker.isPlayer ? enemy : player;
                target.takeDamage(move.dmg / 10);
                effects.push(new VisualEffect(target.x + Math.random()*50, target.y + Math.random()*50, 'slash', move.color));
                ticks++;
                if(ticks > 10) clearInterval(interval);
            }, 200);
        } else if (move.effect === 'instant_dmg' || move.effect === 'swords') {
            const target = attacker.isPlayer ? enemy : player;
            target.takeDamage(move.dmg);
            effects.push(new VisualEffect(target.x+20, target.y+40, 'impact', move.color, 100));
        }

        // Reset domain visuals after time
        setTimeout(() => {
            domainActive = false;
            document.getElementById('bgCanvas').style.background = '#050505';
        }, 3000);
    }

    function executeMove(attacker, target, move) {
        // Damage calc
        let dmg = move.dmg || 0;
        if (attacker.isPlayer) dmg *= playerStats.damageMultiplier;
        if (attacker.buffs.damageBoost) dmg *= 1.5;

        // Visuals
        effects.push(new VisualEffect(attacker.x + attacker.width/2, attacker.y, 'cast', move.color));

        switch(move.type) {
            case 'melee':
                const range = move.range || 80;
                const dist = Math.abs((attacker.x + attacker.width/2) - (target.x + target.width/2));
                const yDist = Math.abs(attacker.y - target.y);
                
                if (dist < range && yDist < 100) {
                    const actualDmg = target.takeDamage(dmg);
                    if (actualDmg > 0) {
                        effects.push(new VisualEffect(target.x + target.width/2, target.y + target.height/2, move.slash ? 'slash' : 'impact', move.color));
                        if (move.knockback) target.x += (attacker.x < target.x ? 1 : -1) * move.knockback;
                        if (move.stun) target.stunned = 60 * move.stun;
                        if (move.dispel) target.buffs = {}; // Toji mechanic
                        
                        // Lifesteal
                        if (attacker.isPlayer && playerStats.lifesteal > 0) {
                            attacker.health = Math.min(attacker.maxHealth, attacker.health + (actualDmg * playerStats.lifesteal));
                        }
                    }
                }
                break;
                
            case 'projectile':
                const count = move.multi || 1;
                for(let i=0; i<count; i++) {
                    setTimeout(() => {
                        const vy = (Math.random() - 0.5) * (count > 1 ? 4 : 0);
                        projectiles.push(new Projectile(
                            attacker.x + (attacker.facing * 40), 
                            attacker.y + 40, 
                            attacker.facing * 12, 
                            vy, 
                            {...move, dmg: dmg/count}, 
                            attacker
                        ));
                    }, i * 100);
                }
                break;
            
            case 'swap':
                // Todo's Boogie Woogie
                const pX = player.x;
                const pY = player.y;
                player.x = enemy.x;
                player.y = enemy.y;
                enemy.x = pX;
                enemy.y = pY;
                spawnText(player.x, player.y, "CLAP!", "#ff69b4");
                target.takeDamage(dmg); // Minor disorientation damage
                break;

            case 'teleport_attack':
            case 'teleport_blitz':
                attacker.x = target.x - (attacker.facing * 50);
                target.takeDamage(dmg);
                effects.push(new VisualEffect(target.x, target.y, 'impact', move.color));
                break;

            case 'beam':
                // Full screen beam
                effects.push(new VisualEffect(canvas.width/2, canvas.height/2, 'beam', move.color));
                setTimeout(() => {
                    const actualDmg = target.takeDamage(dmg);
                    if (actualDmg > 0) spawnText(target.x, target.y, "HIT", move.color);
                }, 300);
                break;
                
            case 'domain':
                triggerDomainExpansion(attacker, move);
                break;
                
            case 'summon':
                supports.push(new SupportEntity(attacker.x, attacker.y, attacker, move.color));
                break;
                
            case 'buff':
                if (move.speedBoost) attacker.buffs.speedBoost = move.duration * 60;
                if (move.damageBoost) attacker.buffs.damageBoost = move.duration * 60;
                if (move.shield) attacker.buffs.shield = move.duration * 60;
                spawnText(attacker.x, attacker.y, "BUFF!", "#fff");
                break;

            case 'heal':
                attacker.health = Math.min(attacker.maxHealth, attacker.health + (move.amount || 50));
                spawnText(attacker.x, attacker.y, "+" + move.amount, "#00ff00");
                break;
                
            case 'stun':
                target.stunned = move.duration * 60;
                target.takeDamage(dmg);
                spawnText(target.x, target.y, "STUN", "#fff");
                break;

            case 'dodge':
                attacker.invuln = move.invuln * 60;
                spawnText(attacker.x, attacker.y, "DODGE", "#fff");
                break;
        }
    }

    function spawnText(x, y, text, color) {
        particles.push(new DamageNumber(x, y, text, color));
    }

    function enemyAI() {
        if (!gameActive || enemy.stunned > 0) return;
        
        const dist = player.x - enemy.x;
        const absDist = Math.abs(dist);
        
        // Movement
        if (absDist > 80) {
            enemy.vx = (dist > 0 ? 1 : -1) * enemy.speed * 0.6;
        } else {
            enemy.vx = 0;
        }
        
        // Attack
        if (Math.random() < 0.025) { 
            const moves = Object.keys(enemy.char.moves);
            const randomMove = moves[Math.floor(Math.random() * moves.length)];
            enemy.attack(randomMove);
        }
    }

    function gameLoop() {
        if (!gameActive) return;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Input Movement (Player)
        player.vx = 0;
        player.vy = 0;
        if (keys['w']) player.vy = -player.speed;
        if (keys['s']) player.vy = player.speed;
        if (keys['a']) { player.vx = -player.speed; player.facing = -1; }
        if (keys['d']) { player.vx = player.speed; player.facing = 1; }
        
        player.update();
        enemy.update();
        enemyAI();
        
        // Projectiles
        projectiles = projectiles.filter(p => {
            p.update();
            p.draw();
            // Hit detection
            const target = p.owner.isPlayer ? enemy : player;
            const dx = p.x - (target.x + target.width/2);
            const dy = p.y - (target.y + target.height/2);
            if (Math.abs(dx) < target.width/2 + p.radius && Math.abs(dy) < target.height/2 + p.radius) {
                target.takeDamage(p.move.dmg);
                effects.push(new VisualEffect(p.x, p.y, 'impact', p.move.color));
                return false; // Destroy projectile
            }
            return p.active;
        });
        
        // Effects & Particles
        effects = effects.filter(e => { e.update(); e.draw(); return e.life > 0; });
        particles = particles.filter(p => { p.update(); p.draw(); return p.life > 0; });
        supports = supports.filter(s => { s.update(); s.draw(); return s.life > 0; });
        
        player.draw();
        enemy.draw();
        
        updateUI();
        checkGameOver();
        
        requestAnimationFrame(gameLoop);
    }

    function updateUI() {
        // Bars
        const pPct = (player.health / player.maxHealth) * 100;
        const ePct = (enemy.health / enemy.maxHealth) * 100;
        document.getElementById('playerHealthBar').style.width = `${Math.max(0, pPct)}%`;
        document.getElementById('enemyHealthBar').style.width = `${Math.max(0, ePct)}%`;
        document.getElementById('ultimateBar').style.width = `${ultimateCharge}%`;
        
        // Text
        document.getElementById('pName').innerText = player.char.name;
        document.getElementById('eName').innerText = enemy.char.name;
        document.getElementById('pHP').innerText = `${Math.ceil(player.health)}/${player.maxHealth}`;
        document.getElementById('eHP').innerText = `${Math.ceil(enemy.health)}/${enemy.maxHealth}`;
        document.getElementById('coinsDisplay').innerText = `ðŸ’° ${coins}`;
        document.getElementById('roundInfo').innerText = `ROUND ${currentRound}`;
        
        // Cooldown Vis
        for(let key in player.cooldowns) {
            const slot = document.getElementById(`slot-${key}`);
            if (slot) {
                if (player.cooldowns[key] > 0) slot.classList.add('cooldown');
                else slot.classList.remove('cooldown');

                if (key === 'ultimate' && ultimateCharge >= 100) slot.classList.add('ready-ult');
                else slot.classList.remove('ready-ult');
            }
        }
    }

    function checkGameOver() {
        if (enemy.health <= 0) {
            gameActive = false;
            coins += 50 + (currentRound * 10);
            openShop();
        } else if (player.health <= 0) {
            gameActive = false;
            document.getElementById('gameOverText').innerText = `You survived until Round ${currentRound}`;
            document.getElementById('gameOver').style.display = 'block';
        }
    }

    function openShop() {
        const shop = document.getElementById('shopScreen');
        const list = document.getElementById('shopItems');
        list.innerHTML = '';
        
        SHOP_ITEMS.forEach(item => {
            const div = document.createElement('div');
            div.className = 'shop-item';
            div.innerHTML = `
                <div style="font-size:2em">${item.icon}</div>
                <div><b>${item.name}</b></div>
                <div style="color:#ffd700">${item.price} ðŸ’°</div>
            `;
            div.onclick = () => {
                if (coins >= item.price) {
                    coins -= item.price;
                    // Apply upgrade
                    if (item.effect === 'maxHealth') {
                        playerStats.maxHealth += item.value;
                    } else {
                        playerStats[item.effect] += item.value;
                    }
                    item.price = Math.floor(item.price * 1.3); // Inflation
                    openShop(); // Refresh
                }
            };
            list.appendChild(div);
        });
        
        shop.style.display = 'block';
    }

    function closeShop() {
        document.getElementById('shopScreen').style.display = 'none';
        currentRound++;
        startGame(false);
    }

    // --- 5. INPUTS ---
    window.addEventListener('keydown', e => {
        keys[e.key.toLowerCase()] = true;
        
        if (!gameActive) return;
        const k = e.key.toLowerCase();
        if (k === 'j') player.attack('light');
        if (k === 'k') player.attack('heavy');
        if (k === 'u') player.attack('special1');
        if (k === 'i') player.attack('special2');
        if (k === 'o') player.attack('support');
        if (k === 'p') player.attack('ultimate');
    });

    window.addEventListener('keyup', e => {
        keys[e.key.toLowerCase()] = false;
    });

    // Start
    init();

</script>
</body>
</html>